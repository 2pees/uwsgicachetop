#!/usr/bin/python

import socket

try:
    import simplejson as json
except ImportError:
    import json
import curses
import time
import atexit
import sys
import traceback
from collections import defaultdict

need_reset = True
screen = None

import locale
locale.setlocale(locale.LC_NUMERIC, "")


def format_num(num):
    """Format a number according to given places.
    Adds commas, etc. Will truncate floats into ints!"""

    try:
        inum = int(num)
        return locale.format("%.*f", (0, inum), True)

    except (ValueError, TypeError):
        return str(num)


def get_max_width(table, index):
    """Get the maximum width of the given column index"""
    return max([len(format_num(row[index])) for row in table])


def human_size(n):
    # G
    if n >= (1024 * 1024 * 1024):
        return "%.1fG" % (n / (1024 * 1024 * 1024))
    # M
    if n >= (1024 * 1024):
        return "%.1fM" % (n / (1024 * 1024))
    # K
    if n >= 1024:
        return "%.1fK" % (n / 1024)
    return "%d" % n


def game_over():
    global need_reset
    if need_reset:
        curses.endwin()


def exc_hook(type, value, tb):
    global need_reset, screen
    need_reset = False
    if screen:
        curses.endwin()
    traceback.print_exception(type, value, tb)


def calc_percent(req, tot):
    if tot == 0:
        return 0.0
    return "%.2f" % ((100 * float(req)) / float(tot))


def parse_hosts(hosts):
    """ returns tuples of host and ports

    :param list|str hosts:
    :return: list of tuples (host, port)
    """
    if isinstance(hosts, basestring):
        hosts = [hosts]

    host_port_tuple_set = set()
    for host in hosts:
        addr = host
        if ':' in host:
            addr_parts = host.split(':')
            addr = (addr_parts[0], int(addr_parts[1]))
        host_port_tuple_set.add(addr)

    return host_port_tuple_set


def load_stats(hosts):
    """ Load uwsgi statistics from *hosts*

    :param set hosts: set of (host, port) tuples
    :return: dict with host: statisticdata
    :rtype: dict
    """
    stats = {}
    sfamily = socket.AF_INET
    for host in hosts:
        try:
            s = socket.socket(sfamily, socket.SOCK_STREAM)
            s.connect(host)
            js = ''
            while True:
                data = s.recv(4096)
                if len(data) < 1:
                    break
                js += data.decode('utf8')
            stats[host] = json.loads(js)
        except Exception as e:
            raise Exception("unable to get uWSGI statistics", e)
        finally:
            s.close()
    return stats


def merge_stats(stats):
    final = {}
    for host, stat in stats.iteritems():
        for cache in stat['caches']:
            name = cache['name']
            if name not in final:
                final[name] = {'hits': 0, 'miss': 0, 'items': 0, 'max_items': 0, 'full': 0}
            tmp = final[name]
            tmp['hits'] += cache['hits']
            tmp['miss'] += cache['miss']
            tmp['items'] += cache['items']
            tmp['full'] += cache['full']
            tmp['max_items'] = cache['max_items']

    for cache in final.values():
        cache['items'] /= len(stats)
    return final


def add_header(screen, last_reqnumber, dt, stats):
    if isinstance(stats, dict):
        tot = sum([worker['requests'] for host_stats in stats.values() for worker in host_stats['workers']])
        tx = human_size(sum([worker['tx'] for host_stats in stats.values() for worker in host_stats['workers']]))
    else:
        tot = 0
        tx = 0

    total_rps = (tot - last_reqnumber) / dt
    last_reqnumber = tot

    screen.addstr(0, 0, "Requests: %d - RPS: %d - tx: %s - hosts: %d" % (tot, int(round(total_rps)), tx, len(stats)))

    return last_reqnumber

if __name__ == '__main__':
    sys.excepthook = exc_hook

    argc = len(sys.argv)

    if argc < 2:
        raise Exception("You have to specify the uWSGI stats socket")

    addr = sys.argv[1:]
    hosts = parse_hosts(addr)

    freq = 3
    try:
        freq = int(sys.argv[2])
    except:
        pass

    screen = curses.initscr()
    curses.start_color()

    screen.timeout(freq * 1000)
    atexit.register(game_over)

    try:
        curses.curs_set(0)
    except:
        pass
    screen.clear()

    try:
        # busy
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_GREEN)
        # cheap
        curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_MAGENTA)
        # pause
        curses.init_pair(3, curses.COLOR_WHITE, curses.COLOR_RED)
        # sig
        curses.init_pair(4, curses.COLOR_WHITE, curses.COLOR_YELLOW)
    except curses.error:
        # the terminal doesn't support colors
        pass

    # RPS calculation
    last_tot_time = time.time()
    last_reqnumber = 0

    last_hits_per_cache = defaultdict(int)
    last_miss_per_cache = defaultdict(int)

    while True:
        screen.clear()

        stats = load_stats(hosts)
        merged_stats = merge_stats(stats)

        dt = time.time() - last_tot_time
        last_reqnumber = add_header(screen, last_reqnumber, dt, stats)

        rows = [("NAME", "HITS", "MISS", "HITS/s", "MISS/s", "ITEMS", "MAXITEMS", "H/M RAT", "FULL")]
        for name, cache in merged_stats.iteritems():
            ratio = calc_percent(cache['hits'], cache['hits'] + cache['miss'])
            hits_per_s = (cache['hits'] - last_hits_per_cache[name]) / dt
            miss_per_s = (cache['miss'] - last_miss_per_cache[name]) / dt
            last_hits_per_cache[name] = cache['hits']
            last_miss_per_cache[name] = cache['miss']
            rows.append((name, cache['hits'], cache['miss'], hits_per_s, miss_per_s, cache['items'], cache['max_items'], ratio, cache['full']))

        last_tot_time = time.time()

        col_paddings = []
        for i in range(len(rows[0])):
            col_paddings.append(get_max_width(rows, i))

        pos = 1
        # heading
        heading = rows.pop(0)
        screen.addstr(pos, 0, reduce(lambda x, y: x + str(heading[y]).ljust(col_paddings[y] + 2), range(len(heading)), ""), curses.A_BOLD)
        pos = 2

        for row in rows:
            screen.addstr(pos, 0, "")
            for i in range(len(row)):
                screen.addstr(format_num(row[i]).ljust(col_paddings[i] + 2))
            pos += 1

        screen.refresh()
        #s.close()

        ch = screen.getch()
        if ch == ord('q'):
            game_over()
            break
